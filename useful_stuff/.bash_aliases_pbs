# save this file as ~/.bash_aliases, then add the following lines to ~/.bashrc
#
#     # Load aliases
#     if [ -f ~/.bash_aliases ]; then
#         . ~/.bash_aliases
#     fi
#

# alias qstat to show relevant information about your own jobs 
alias qstat='squeue --me -o "%.18i %.9P %.32j %.8u %.8T %.10M %.6D %R"'

# template to transfer to your own user folder
alias ada="cd /group/pawsey0420/ada && pwd"


# batch rename all files with name $1* to name $2*
rename_files() {
  local old_pattern="$1"
  local new_pattern="$2"
  for file in "$old_pattern"*; do
    mv "$file" "${file/$old_pattern/$new_pattern}"
  done
}

# cleanout:  changes \r (carriage return) to \n (newline) to make slurm-TKTKTK.out files easier to read on some ssh platforms
alias cleanout="sed -i 's|\r|\n|g'" # clean output file carriage returns for readability


# cleanoe:
cleanoe() {
# reformat all .[oe][0-9]* files to be more readable, and compartmentalises them into ./oe/
# if you pass the name of as .[oe][0-9]* file as an argument, it will use less to 
# open that file and scroll to the end

# Background:

# every pbs job saves stdout to .o[0-9]* and stderr to .e[0-9]*
# these files are very valuable during benchmarking and debugging, but are typically 
# compeltely useless once a job is complete

# We run our simulation in a large number of  multiple 4 hour blocks, which makes
# a lot of *.[oe][0-9]* files. This makes ls and ll output very hard to read, and
# chews up our inode quota

# cleanoe reformats the files for readabilty, then moves them all to ./oe/ to keep
# them out of the way, and make them easy to delete when you're done.

# this also reformats them to make them easier to read

# some terminal clients will render carriage returns as ^M rather than as a line break
# which means the entire step by step mdrun output shows as one very, very long line
# this sucks to interact with 

# hence, for all *.[oe][0-9]* files in the working directory, change carriage returns to newlines.  
# this makes files much more readable through some terminal platforms


if [ -f /usr/local/bin/gsed ] 
# check if gsed is installed.  On bsd systems like macos you need to use gsed if on a mac
then
    gsed -i 's|\r|\n|g' *.[oe][0-9]*
else
    sed -i 's|\r|\n|g' *.[oe][0-9]*
fi

mydir="${PWD##*/}"

if [ $mydir != "oe" ]
then

    if [ ! -d oe ]
    then
        mkdir oe
    fi
    mv *.e[0-9]* oe/
    mv *.o[0-9]* oe/
fi

if [ -n "$1" ]; then
# if passed an argument, open the file with name oe/$arg
  less +G oe/$1
fi
}



# qstat -f | grep 'PBS_O_WORKDIR\|Job Id'
qwhich() {
echo "" >> ~/joblog.log
echo "" >> ~/joblog.log
date >> ~/joblog.log
qstat -f | grep 'PBS_O_WORKDIR\|Job Id\|run[0-9][,]\|,PBS_O_SYSTEM' | sed 's/\t//g' | sed 's/PBS_O_WORKDIR=//' | sed 's/,PBS_O_SYSTEM=Linux,PROJECT=q95,PBS_NCI_HT=1,//' | tr -d '\n'  | sed 's/.gadi-pbs/   /g' | sed 's/Job Id/\nJob Id/g' | tr -d "," | sort -k 4 >> ~/joblog.log
echo "" >> ~/joblog.log
less +G ~/joblog.log
}